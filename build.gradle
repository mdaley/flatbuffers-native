import org.gradle.api.internal.TaskInputsInternal
import org.gradle.api.internal.TaskOutputsInternal

import java.nio.file.Files

plugins {
    id 'java'
}

group 'com.sequsoft.flatbuffers-native'
version '1.12.0.1-SNAPSHOT'

sourceCompatibility = 1.8

repositories {
    mavenCentral()
}

dependencies {
    testImplementation group: 'junit', name: 'junit', version: '4.12'
}

task displayProjectProperties {

    doLast() {

        for(Map.Entry p: project.getProperties()) {
            println(p.toString() + "\n");
        }
    }
}

class DockerBuilder extends AbstractExecTask<DockerBuilder> {
    private String source
    private String image

    DockerBuilder() {
        super(DockerBuilder.class)
    }

    @Internal
    @Override
    TaskInputsInternal getInputs() {
        TaskInputsInternal inputs = super.getInputs()

        def sourceFile = new File(source)
        if (sourceFile.exists()) {
            inputs.file(sourceFile.toPath())
        }
        return inputs;
    }

    String dockerImageId() {
        def action = getExecActionFactory().newExecAction()
        def output = new ByteArrayOutputStream()
        def err = new ByteArrayOutputStream()
        action.commandLine("docker", "inspect", "-f", "{{.Id}}", image)
                .setStandardOutput(output)
                .setErrorOutput(err)
                .setIgnoreExitValue(true)
        action.execute()
        def str = new String(output.toByteArray())
        return (str != "") ? str : null
    }

    String savedDockerImageId() {
        def path = getProject().getBuildDir().toPath().resolve("dockerImageIds")
        if (Files.notExists(path)) {
            return null
        }
        def savedIdFile = new File(path.toString(), image)
        if (Files.notExists(savedIdFile.toPath())) {
            return null
        }
        return savedIdFile.text
    }

    @Internal
    @Override
    TaskOutputsInternal getOutputs() {
        TaskOutputsInternal outputs = super.getOutputs()
        outputs.upToDateWhen( {
            def savedImageId = savedDockerImageId()
            def imageId = dockerImageId()

            savedImageId != null && imageId != null && savedImageId == imageId
        })

        return outputs
    }

    @Option(option = "source", description = "The name of the source Dockerfile")
    void setSource(String source) {
        this.source = source
    }

    @Option(option = "image", description = "name of the image that will be produced")
    void setImage(String image) {
        this.image = image
    }

    @Input
    String getSource() {
        return source
    }

    @Input
    String getImage() {
        return image
    }

    void saveDockerImageId() {
        def imageId = dockerImageId()
        println("Saving docker image id ${imageId}")
        def path = getProject().getBuildDir().toPath().resolve("dockerImageIds")
        if (Files.notExists(path)) {
            Files.createDirectory(path)
        }
        new File(path.toString(), image).text = imageId
    }

    @TaskAction
    @Override
    protected void exec() {
        println("Running docker build: docker build -q -t ${image} -f ${source} .")
        commandLine("docker", "build", "-t", image, "-f", source, ".")
        super.exec()
        saveDockerImageId()
    }
}

List<Task> dockerBuildTasks = new ArrayList<>();

task mytask() {
    println "Hello!"
}

file("./platforms").eachDir { os ->
    file(os).eachDir { arch ->
        println arch.path
        def osName = os.toString().substring(os.toString().lastIndexOf("/") + 1)
        def archName = arch.toString().substring(arch.toString().lastIndexOf("/") + 1)
        def name = "dockerBuild_${osName}_${archName}"
        println name

        if (file("${arch.path}/Dockerfile").exists()) {
            def innerTask = tasks.register(name, DockerBuilder) {
                source = "${arch.path}/Dockerfile"
                image = "fbbuild-${osName}-${archName}"
            }

            dockerBuildTasks.add(innerTask)
        }
    }
}

build.dependsOn  {
    mytask
    dockerBuildTasks
}