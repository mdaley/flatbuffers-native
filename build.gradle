import org.gradle.api.internal.TaskInputsInternal
import org.gradle.api.internal.TaskOutputsInternal

import java.nio.file.Files

plugins {
    id 'java'
}

group 'com.sequsoft.flatbuffers-native'
version '1.12.0.1-SNAPSHOT'

sourceCompatibility = 1.8

repositories {
    mavenCentral()
}

dependencies {
    testImplementation group: 'junit', name: 'junit', version: '4.12'
}

task displayProjectProperties {

    doLast() {

        for(Map.Entry p: project.getProperties()) {
            println(p.toString() + "\n");
        }
    }
}

class DockerBuilder extends AbstractExecTask<DockerBuilder> {
    private String source
    private String image

    DockerBuilder() {
        super(DockerBuilder.class)
    }

    @Internal
    @Override
    TaskInputsInternal getInputs() {
        TaskInputsInternal inputs = super.getInputs()

        def sourceFile = new File(source)
        if (sourceFile.exists()) {
            inputs.file(sourceFile.toPath())
        }
        return inputs;
    }

    String dockerImageId() {
        def action = getExecActionFactory().newExecAction()
        def output = new ByteArrayOutputStream()
        def err = new ByteArrayOutputStream()
        action.commandLine("docker", "inspect", "-f", "{{.Id}}", image)
                .setStandardOutput(output)
                .setErrorOutput(err)
                .setIgnoreExitValue(true)
        action.execute()
        def str = new String(output.toByteArray())
        return (str != "") ? str : null
    }

    String savedDockerImageId() {
        def path = getProject().getBuildDir().toPath().resolve("dockerImageIds")
        if (Files.notExists(path)) {
            return null
        }
        def savedIdFile = new File(path.toString(), image)
        if (Files.notExists(savedIdFile.toPath())) {
            return null
        }
        return savedIdFile.text
    }

    @Internal
    @Override
    TaskOutputsInternal getOutputs() {
        TaskOutputsInternal outputs = super.getOutputs()
        outputs.upToDateWhen( {
            def savedImageId = savedDockerImageId()
            def imageId = dockerImageId()

            savedImageId != null && imageId != null && savedImageId == imageId
        })

        return outputs
    }

    @Option(option = "source", description = "The name of the source Dockerfile")
    void setSource(String source) {
        this.source = source
    }

    @Option(option = "image", description = "name of the image that will be produced")
    void setImage(String image) {
        this.image = image
    }

    @Input
    String getSource() {
        return source
    }

    @Input
    String getImage() {
        return image
    }

    void saveDockerImageId() {
        def imageId = dockerImageId()
        println("Saving docker image id ${imageId}")
        def path = getProject().getBuildDir().toPath().resolve("dockerImageIds")
        if (Files.notExists(path)) {
            Files.createDirectory(path)
        }
        new File(path.toString(), image).text = imageId
    }

    @TaskAction
    @Override
    protected void exec() {
        String[] cmd = ["docker", "build", "-t", image, "-f", source, "."]
        println("Running docker build: " + cmd.join(" "))
        commandLine(cmd)
        super.exec()
        saveDockerImageId()
    }
}

class NativeBuildTask extends AbstractExecTask<NativeBuildTask> {
    private String image
    private String os
    private String arch
    private String repo
    private String commit

    private String outputDir
    private String nativeBuildPath
    private String sharedLibraryCompilePath

    NativeBuildTask() {
        super(NativeBuildTask.class)
    }

    @Option(option = "image", description = "name of the image on which the native build will be run")
    void setImage(String image) {
        this.image = image
    }

    @Input
    String getImage() {
        return image
    }

    @Option(option = "os", description = "the operating system of the native executable")
    void setOs(String os) {
        this.os = os
    }

    @Input
    String getOs() {
        return os
    }

    @Option(option = "arch", description = "the architecture of the native executable")
    void setArch(String arch) {
        this.arch = arch
    }

    @Input
    String getArch() {
        return arch
    }

    @Option(option = "repo", description = "HTTP URL to the flatbuffers repository")
    void setRepo(String repo) {
        this.repo = repo
    }

    @Input
    String getRepo() {
        return repo
    }

    @Option(option = "commit", description = "The commit of the flatbuffers code to be compiled, e.g. v1.12.0, or a commit id")
    void setCommit(String commit) {
        this.commit = commit
    }

    @Input
    String getCommit() {
        return commit
    }

    @Internal
    @Override
    TaskOutputsInternal getOutputs() {
        TaskOutputsInternal outputs = super.getOutputs()
        outputs.dirs {
            getProject().getBuildDir().toPath().resolve("natives").resolve(os).resolve(arch)
        }

        return outputs
    }

    private createOutputDirectory() {
        def path = getProject().getBuildDir().toPath().resolve("natives").resolve(os).resolve(arch)
        Files.createDirectories(path)
        outputDir = path.toString()
    }

    private String resolvePath(String name) {
        def path = getProject().getProjectDir().toPath().resolve("platforms").resolve(os).resolve(arch)

        if (!Files.exists(path.resolve(name))) {
            path = path.normalize().getParent()
            if (!Files.exists(path.resolve(name))) {
                path = path.normalize().getParent()
            }
        }

        if (!Files.exists(path.resolve(name))) {
            throw new RuntimeException("${name} file does not exist at ${path}")
        }

        def resolvedPath = path.resolve(name)
        println("Setting ${name}'s path to ${resolvedPath}")
        return resolvedPath.toString()
    }

    private resolveCompileScript() {
        nativeBuildPath = resolvePath("native-build")
    }

    private resolveSharedLibraryCompileScript() {
        sharedLibraryCompilePath = resolvePath("build-shared-library")
    }

    @TaskAction
    @Override
    protected void exec() {
        createOutputDirectory()
        resolveCompileScript()
        resolveSharedLibraryCompileScript()

        String[] cmd = ["docker", "run", "-v", "${outputDir}:/out", "-v", "${nativeBuildPath}:/native-build",
                "-v", "${sharedLibraryCompilePath}:/shared-library-build",
                "-e", "FLATBUFFERS_REPO=${repo}", "-e", "FLATBUFFERS_COMMIT=${commit}",
                "--entrypoint", "/bin/sh", image, "/native-build"]

        println("Running compilation on docker container using: " + cmd.join(" "))
        commandLine(cmd)
        super.exec()
    }
}

List<Task> dynamicTasks = new ArrayList<>()

file("./platforms").eachDir { os ->
    file(os).eachDir { arch ->
        def osName = os.toString().substring(os.toString().lastIndexOf("/") + 1)
        def archName = arch.toString().substring(arch.toString().lastIndexOf("/") + 1)
        def name = "dockerBuild_${osName}_${archName}"

        if (!file("${arch.path}/skip").exists()) {
            if (file("${arch.path}/Dockerfile").exists()) {

                // docker build
                def imageName = "fbbuild-${osName}-${archName}"
                def dockerBuildTask = tasks.register(name, DockerBuilder) {
                    source = "${arch.path}/Dockerfile"
                    image = imageName
                }

                println("Added task to build docker image for ${osName}-${archName}")
                dynamicTasks.add(dockerBuildTask)

                // compilation
                def nativeBuildTask = tasks.register("nativeBuildTask_${osName}_${archName}", NativeBuildTask) { t ->
                    t.os = osName
                    t.arch = archName
                    t.dependsOn = [dockerBuildTask]
                    t.image = imageName
                    t.repo = flatbuffersRepo
                    t.commit = flatbuffersCommit
                }

                println("Adding task to compile native code on ${imageName} for ${osName} / ${archName}")
                dynamicTasks.add(nativeBuildTask)

                // packaging a jar
                def jarTask = tasks.register("jarTask_${osName}_${archName}", Jar) { t ->
                    t.doFirst {
                        println("Creating native jar for ${osName} / ${archName}")
                    }
                    t.dependsOn = [nativeBuildTask]
                    t.archiveBaseName.set("flatbuffers-native")
                    t.version "${project.version}"
                    t.archiveClassifier.set("${osName}-${archName}")
                    t.manifest {
                        attributes "Implementation-Title" : "Flatbuffers native container for ${osName} / ${archName}",
                            "Implementation-Version" : "${project.version}",
                            "Implementation-Vendor" : "Sequsoft"
                    }
                    t.from("${buildDir}/natives/${osName}/${archName}") {
                        exclude "flat*"
                        into "/natives/${osName}/${archName}"
                    }
                }

                println("Adding task to packge native code into jar for ${osName} / ${archName}")
                dynamicTasks.add(jarTask)

            }
        } else {
            println("Skipping tasks for ${osName} ${archName}")
        }
    }
}

build.dependsOn  {
    dynamicTasks
}